<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Soul-Eater - Soohoon Lee</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: 'Courier New', monospace;
            background: #1a1a1a;
            display: flex;
            justify-content: center;
            align-items: center;
            min-height: 100vh;
            overflow: hidden;
        }

        #gameContainer {
            position: relative;
            border: 4px solid #444;
            box-shadow: 0 0 20px rgba(0, 0, 0, 0.5);
        }

        #gameCanvas {
            display: block;
            background: #2d5016;
            image-rendering: pixelated;
            image-rendering: crisp-edges;
        }

        #ui {
            position: absolute;
            bottom: 0;
            left: 0;
            right: 0;
            background: rgba(0, 0, 0, 0.85);
            border-top: 3px solid #00ff00;
            padding: 0;
            backdrop-filter: blur(10px);
        }

        .bottom-ui-container {
            display: flex;
            align-items: center;
            padding: 15px 20px;
            gap: 30px;
        }

        .stat-section {
            display: flex;
            flex-direction: column;
            gap: 5px;
        }

        .stat-bar-wrapper {
            display: flex;
            align-items: center;
            gap: 10px;
        }

        .stat-label {
            color: #aaa;
            font-size: 11px;
            text-transform: uppercase;
            letter-spacing: 1px;
            min-width: 60px;
            font-weight: 600;
        }

        .stat-bar {
            position: relative;
            width: 200px;
            height: 20px;
            background: #1a1a1a;
            border: 2px solid #333;
            border-radius: 3px;
            overflow: hidden;
        }

        .stat-bar-fill {
            height: 100%;
            transition: width 0.3s ease;
            position: relative;
        }

        .health-fill {
            background: linear-gradient(90deg, #ff3333, #ff6666);
        }

        .exp-fill {
            background: linear-gradient(90deg, #ffaa00, #ffcc00);
        }

        .stat-text {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            color: white;
            font-size: 11px;
            font-weight: 700;
            text-shadow: 1px 1px 2px rgba(0, 0, 0, 0.8);
            z-index: 1;
        }

        .currency-stats {
            display: flex;
            gap: 20px;
            margin-left: auto;
        }

        .currency-item {
            display: flex;
            align-items: center;
            gap: 8px;
            background: rgba(255, 255, 255, 0.05);
            padding: 8px 15px;
            border-radius: 5px;
            border: 1px solid rgba(255, 255, 255, 0.1);
        }

        .currency-icon {
            font-size: 16px;
        }

        .currency-label {
            color: #888;
            font-size: 10px;
            text-transform: uppercase;
        }

        .currency-value {
            color: #fff;
            font-size: 16px;
            font-weight: 700;
        }

        .level-display {
            background: linear-gradient(135deg, #667eea, #764ba2);
            padding: 10px 20px;
            border-radius: 8px;
            text-align: center;
            border: 2px solid rgba(255, 255, 255, 0.2);
        }

        .level-label {
            color: rgba(255, 255, 255, 0.8);
            font-size: 9px;
            text-transform: uppercase;
            letter-spacing: 1px;
        }

        .level-number {
            color: white;
            font-size: 24px;
            font-weight: 700;
            line-height: 1;
        }

        #waveInfo {
            position: absolute;
            top: 10px;
            right: 10px;
            background: rgba(0, 0, 0, 0.7);
            padding: 15px;
            border-radius: 5px;
            color: white;
            text-align: right;
            min-width: 150px;
        }

        .wave-number {
            font-size: 24px;
            font-weight: bold;
            color: #ff6666;
        }

        .enemy-count {
            font-size: 14px;
            color: #aaa;
            margin-top: 5px;
        }

        .world-size {
            font-size: 12px;
            color: #ffaa00;
            margin-top: 8px;
        }

        #worldExpanded {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            background: rgba(255, 170, 0, 0.95);
            padding: 30px 50px;
            border-radius: 10px;
            color: #000;
            font-size: 24px;
            font-weight: bold;
            display: none;
            animation: fadeInOut 3s;
        }

        #soulUnlocked {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            background: rgba(0, 0, 0, 0.95);
            padding: 40px 60px;
            border-radius: 15px;
            color: #fff;
            font-size: 28px;
            font-weight: bold;
            display: none;
            animation: fadeInOut 4s;
            border: 3px solid;
            text-align: center;
        }

        #statAllocationPanel {
            position: absolute;
            right: -280px;
            top: 50%;
            transform: translateY(-50%);
            background: rgba(0, 0, 0, 0.9);
            padding: 20px;
            border-radius: 10px 0 0 10px;
            border: 2px solid #9933ff;
            border-right: none;
            color: white;
            width: 280px;
            transition: right 0.3s ease;
            max-height: 600px;
            overflow-y: auto;
        }

        #statAllocationPanel.open {
            right: 0;
        }

        #statAllocationPanel::-webkit-scrollbar {
            width: 6px;
        }

        #statAllocationPanel::-webkit-scrollbar-track {
            background: #1a1a1a;
        }

        #statAllocationPanel::-webkit-scrollbar-thumb {
            background: #ffaa00;
            border-radius: 3px;
        }

        #statMenuTab {
            position: absolute;
            left: -50px;
            top: 50%;
            transform: translateY(-50%);
            background: rgba(0, 0, 0, 0.9);
            padding: 15px 10px;
            border-radius: 10px 0 0 10px;
            cursor: pointer;
            border: 2px solid #9933ff;
            border-right: none;
            transition: all 0.3s ease;
            writing-mode: vertical-rl;
            text-orientation: mixed;
            font-weight: bold;
            color: #9933ff;
        }

        #statMenuTab:hover {
            background: rgba(153, 51, 255, 0.2);
            left: -55px;
        }

        #statMenuTab.has-points {
            animation: pulsePurple 1.5s infinite;
        }

        @keyframes pulsePurple {
            0%, 100% {
                box-shadow: 0 0 0 0 rgba(153, 51, 255, 0.7);
            }
            50% {
                box-shadow: 0 0 20px 10px rgba(153, 51, 255, 0);
            }
        }

        .stat-panel-title {
            font-size: 18px;
            font-weight: bold;
            text-align: center;
            margin-bottom: 5px;
            color: #9933ff;
        }

        .stat-panel-subtitle {
            text-align: center;
            color: #aaa;
            margin-bottom: 15px;
            font-size: 11px;
        }

        .stat-points-available {
            text-align: center;
            font-size: 16px;
            margin-bottom: 15px;
            color: #9933ff;
            font-weight: bold;
        }

        .stat-allocation-item {
            display: flex;
            flex-direction: column;
            padding: 10px;
            margin-bottom: 10px;
            background: rgba(255, 255, 255, 0.05);
            border-radius: 6px;
            border: 1px solid rgba(255, 255, 255, 0.1);
        }

        .stat-row {
            display: flex;
            align-items: center;
            justify-content: space-between;
        }

        .stat-info {
            flex: 1;
        }

        .stat-name {
            font-size: 13px;
            font-weight: 600;
            color: #fff;
            margin-bottom: 2px;
        }

        .stat-description {
            font-size: 9px;
            color: #888;
        }

        .stat-current {
            font-size: 14px;
            font-weight: 700;
            color: #00ff00;
            margin: 0 10px;
            min-width: 50px;
            text-align: center;
        }

        .stat-plus-btn {
            background: linear-gradient(135deg, #9933ff, #6622cc);
            color: #fff;
            border: none;
            width: 30px;
            height: 30px;
            border-radius: 6px;
            font-size: 18px;
            font-weight: bold;
            cursor: pointer;
            transition: all 0.2s;
        }

        .stat-plus-btn:hover {
            transform: scale(1.1);
            box-shadow: 0 0 15px rgba(153, 51, 255, 0.5);
        }

        .stat-plus-btn:disabled {
            background: #333;
            color: #666;
            cursor: not-allowed;
            transform: none;
            box-shadow: none;
        }

        .confirm-stats-btn {
            width: 100%;
            padding: 10px;
            margin-top: 15px;
            background: linear-gradient(135deg, #9933ff, #6622cc);
            color: #fff;
            border: none;
            border-radius: 8px;
            font-size: 14px;
            font-weight: bold;
            cursor: pointer;
            transition: all 0.3s;
        }

        .confirm-stats-btn:hover {
            transform: translateY(-2px);
            box-shadow: 0 5px 20px rgba(153, 51, 255, 0.5);
        }

        /* Class Selection */
        #classSelection {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            background: rgba(0, 0, 0, 0.95);
            padding: 40px;
            border-radius: 15px;
            border: 3px solid #00ff00;
            color: white;
            display: none;
            z-index: 10001;
            max-width: 800px;
        }

        .class-title {
            font-size: 32px;
            font-weight: bold;
            text-align: center;
            margin-bottom: 15px;
            color: #00ff00;
        }

        .class-subtitle {
            text-align: center;
            color: #aaa;
            margin-bottom: 30px;
            font-size: 14px;
        }

        .class-grid {
            display: grid;
            grid-template-columns: repeat(2, 1fr);
            gap: 20px;
        }

        .class-card {
            background: rgba(255, 255, 255, 0.05);
            border: 3px solid rgba(255, 255, 255, 0.2);
            border-radius: 10px;
            padding: 25px;
            cursor: pointer;
            transition: all 0.3s;
            text-align: center;
        }

        .class-card:hover {
            border-color: #00ff00;
            background: rgba(0, 255, 0, 0.1);
            transform: translateY(-5px);
            box-shadow: 0 10px 30px rgba(0, 255, 0, 0.3);
        }

        .class-icon {
            font-size: 48px;
            margin-bottom: 15px;
        }

        .class-name {
            font-size: 24px;
            font-weight: bold;
            margin-bottom: 10px;
            color: #fff;
        }

        .class-description {
            font-size: 13px;
            color: #aaa;
            margin-bottom: 15px;
            line-height: 1.5;
        }

        .class-stats {
            font-size: 11px;
            color: #00ff00;
            text-align: left;
            background: rgba(0, 0, 0, 0.3);
            padding: 10px;
            border-radius: 5px;
        }

        .class-stats div {
            margin-bottom: 5px;
        }

        @keyframes fadeInOut {
            0% { opacity: 0; transform: translate(-50%, -50%) scale(0.5); }
            20% { opacity: 1; transform: translate(-50%, -50%) scale(1); }
            80% { opacity: 1; transform: translate(-50%, -50%) scale(1); }
            100% { opacity: 0; transform: translate(-50%, -50%) scale(0.5); }
        }

        #instructions {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            background: rgba(0, 0, 0, 0.9);
            padding: 30px;
            border-radius: 10px;
            color: white;
            text-align: center;
            max-width: 500px;
        }

        #instructions h2 {
            color: #ffaa00;
            margin-bottom: 20px;
        }

        #instructions p {
            margin-bottom: 10px;
            line-height: 1.6;
        }

        .start-btn {
            margin-top: 20px;
            padding: 15px 40px;
            background: #ffaa00;
            border: none;
            border-radius: 5px;
            font-size: 18px;
            font-weight: bold;
            cursor: pointer;
            font-family: 'Courier New', monospace;
        }

        .start-btn:hover {
            background: #ffcc00;
        }

        #gameOver {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            background: rgba(0, 0, 0, 0.95);
            padding: 40px;
            border-radius: 10px;
            color: white;
            text-align: center;
            display: none;
        }

        #gameOver h2 {
            font-size: 36px;
            margin-bottom: 20px;
            color: #ff6666;
        }

        .final-score {
            font-size: 24px;
            margin-bottom: 20px;
            color: #ffaa00;
        }
    </style>
</head>
<body>
    <div id="gameContainer">
        <canvas id="gameCanvas" width="1000" height="700"></canvas>
        
        <!-- UI - Bottom Bar -->
        <div id="ui">
            <div class="bottom-ui-container">
                <!-- Level Display -->
                <div class="level-display">
                    <div class="level-label">Level</div>
                    <div class="level-number" id="playerLevel">1</div>
                </div>

                <!-- Stats Section -->
                <div class="stat-section">
                    <!-- Health Bar -->
                    <div class="stat-bar-wrapper">
                        <span class="stat-label">HP</span>
                        <div class="stat-bar">
                            <div class="stat-bar-fill health-fill" id="healthBar" style="width: 100%"></div>
                            <div class="stat-text" id="healthText">100/100</div>
                        </div>
                    </div>

                    <!-- EXP Bar -->
                    <div class="stat-bar-wrapper">
                        <span class="stat-label">EXP</span>
                        <div class="stat-bar">
                            <div class="stat-bar-fill exp-fill" id="expBar" style="width: 0%"></div>
                            <div class="stat-text" id="expText">0/100</div>
                        </div>
                    </div>
                </div>

                <!-- Currency Stats -->
                <div class="currency-stats">
                    <div class="currency-item">
                        <span class="currency-icon">üëª</span>
                        <div>
                            <div class="currency-label">Souls</div>
                            <div class="currency-value" id="soulsCount">0</div>
                        </div>
                    </div>

                    <div class="currency-item">
                        <span class="currency-icon">‚≠ê</span>
                        <div>
                            <div class="currency-label">Score</div>
                            <div class="currency-value" id="score">0</div>
                        </div>
                    </div>
                </div>
            </div>
        </div>

        <!-- Wave Info -->
        <button id="soundToggle" onclick="AudioSystem.enabled=!AudioSystem.enabled; this.textContent=AudioSystem.enabled?'üîä Sound':'üîá Muted';" style="position:absolute;top:10px;left:170px;background:rgba(0,0,0,0.8);border:2px solid #00ff00;color:#00ff00;padding:8px 12px;cursor:pointer;font-family:inherit;border-radius:5px;">üîä Sound</button>
        <div id="waveInfo">
            <div style="font-size: 12px; color: #aaa;">WAVE</div>
            <div class="wave-number" id="waveNumber">1</div>
            <div class="enemy-count" id="enemyCount">Enemies: 0</div>
            <div style="margin-top: 10px; font-size: 12px; color: #aaa;" id="waveTimer">Next wave in: 30s</div>
            <div class="world-size" id="worldSize">World: 800 x 600</div>
        </div>

        <!-- World Expanded Notification -->
        <div id="worldExpanded">üåç WORLD EXPANDED! üåç</div>

        <!-- Soul Unlocked Notification -->
        <div id="soulUnlocked"></div>

        <!-- Stat Allocation Panel -->
        <div id="statAllocationPanel">
            <div id="statMenuTab" onclick="toggleStatMenu()">üìä STATS</div>
            <div class="stat-panel-title">‚≠ê Stats</div>
            <div class="stat-panel-subtitle">Level <span id="levelUpNumber">1</span></div>
            <div class="stat-points-available">
                Points: <span id="availablePoints">0</span>
            </div>

            <div class="stat-allocation-item">
                <div class="stat-row">
                    <div class="stat-info">
                        <div class="stat-name">‚ù§Ô∏è Max HP</div>
                        <div class="stat-description">+20 per point</div>
                    </div>
                    <div class="stat-current" id="currentMaxHP">100</div>
                    <button class="stat-plus-btn" onclick="allocateStat('health')">+</button>
                </div>
            </div>

            <div class="stat-allocation-item">
                <div class="stat-row">
                    <div class="stat-info">
                        <div class="stat-name">‚öîÔ∏è Attack</div>
                        <div class="stat-description">+5 damage</div>
                    </div>
                    <div class="stat-current" id="currentAttack">25</div>
                    <button class="stat-plus-btn" onclick="allocateStat('attack')">+</button>
                </div>
            </div>

            <div class="stat-allocation-item">
                <div class="stat-row">
                    <div class="stat-info">
                        <div class="stat-name">üí® Speed</div>
                        <div class="stat-description">+0.3 speed</div>
                    </div>
                    <div class="stat-current" id="currentSpeed">3.0</div>
                    <button class="stat-plus-btn" onclick="allocateStat('speed')">+</button>
                </div>
            </div>

            <div class="stat-allocation-item">
                <div class="stat-row">
                    <div class="stat-info">
                        <div class="stat-name">‚ö° Fire Rate</div>
                        <div class="stat-description">-50ms cooldown</div>
                    </div>
                    <div class="stat-current" id="currentFireRate">500ms</div>
                    <button class="stat-plus-btn" onclick="allocateStat('firerate')">+</button>
                </div>
            </div>

            <button class="confirm-stats-btn" onclick="confirmStats()" id="confirmBtn">
                Apply Stats
            </button>
        </div>

        <!-- Class Selection -->
        <div id="classSelection">
            <div class="class-title">‚öîÔ∏è Choose Your Class ‚öîÔ∏è</div>
            <div class="class-subtitle">Each class has unique attack patterns and playstyles</div>
            
            <div class="class-grid">
                <div class="class-card" onclick="selectClass('warrior')">
                    <div class="class-icon">üõ°Ô∏è</div>
                    <div class="class-name">Warrior</div>
                    <div class="class-description">
                        Tank class with high durability. Shoots powerful melee-ranged energy slashes.
                    </div>
                    <div class="class-stats">
                        <div>‚öîÔ∏è Attack: Medium-High</div>
                        <div>üî´ Range: Short</div>
                        <div>‚ö° Speed: Slow projectiles</div>
                        <div>üéØ Pattern: Single heavy slash</div>
                    </div>
                </div>

                <div class="class-card" onclick="selectClass('bowman')">
                    <div class="class-icon">üèπ</div>
                    <div class="class-name">Bowman</div>
                    <div class="class-description">
                        Ranged specialist. Shoots fast arrows that pierce through enemies.
                    </div>
                    <div class="class-stats">
                        <div>‚öîÔ∏è Attack: Medium</div>
                        <div>üî´ Range: Very Long</div>
                        <div>‚ö° Speed: Fast projectiles</div>
                        <div>üéØ Pattern: Piercing arrows</div>
                    </div>
                </div>

                <div class="class-card" onclick="selectClass('magician')">
                    <div class="class-icon">üîÆ</div>
                    <div class="class-name">Magician</div>
                    <div class="class-description">
                        Magic caster. Shoots orbiting magic orbs that deal splash damage.
                    </div>
                    <div class="class-stats">
                        <div>‚öîÔ∏è Attack: High (Area)</div>
                        <div>üî´ Range: Medium</div>
                        <div>‚ö° Speed: Medium projectiles</div>
                        <div>üéØ Pattern: 3 orbiting orbs</div>
                    </div>
                </div>

                <div class="class-card" onclick="selectClass('assassin')">
                    <div class="class-icon">üó°Ô∏è</div>
                    <div class="class-name">Assassin</div>
                    <div class="class-description">
                        High mobility DPS. Throws rapid shurikens in bursts of 3.
                    </div>
                    <div class="class-stats">
                        <div>‚öîÔ∏è Attack: Low (Multi-hit)</div>
                        <div>üî´ Range: Medium</div>
                        <div>‚ö° Speed: Very Fast</div>
                        <div>üéØ Pattern: Triple burst</div>
                    </div>
                </div>
            </div>
        </div>

        <!-- Instructions -->
        <div id="instructions">
            <h2>üëª SOUL-EATER</h2>
            <p><strong>WASD</strong> - Move your character</p>
            <p><strong>Collect souls</strong> by walking over them to earn currency</p>
            <p><strong>Soul Colors:</strong> üî¥ Red (5) ‚Üí üü† Orange (10) ‚Üí üü° Yellow (15) ‚Üí üü¢ Green (25) ‚Üí üîµ Blue (40) ‚Üí üü£ Purple (60)</p>
            <p><strong>Level up</strong> to gain stat points and customize your character!</p>
            <p style="margin-top: 20px; color: #ffaa00;">Choose your class and survive the waves!</p>
            <button class="start-btn" onclick="startGame()">START GAME</button>
        </div>

        <!-- Game Over -->
        <div id="gameOver">
            <h2>üíÄ GAME OVER üíÄ</h2>
            <div class="final-score">Wave Reached: <span id="finalWave">0</span></div>
            <div class="final-score">Final Score: <span id="finalScore">0</span></div>
            <button class="start-btn" onclick="location.reload()">PLAY AGAIN</button>
        </div>
    </div>

    <script>
        // ============ AUDIO SYSTEM ============
        const AudioSystem = {
            enabled: true,
            ctx: null,
            init() { this.ctx = new (window.AudioContext || window.webkitAudioContext)(); },
            ensure() { if (!this.ctx) this.init(); if (this.ctx.state === "suspended") this.ctx.resume(); },
            play(freq, dur, type = "square", vol = 0.2) {
                if (!this.enabled) return;
                this.ensure();
                const osc = this.ctx.createOscillator();
                const gain = this.ctx.createGain();
                osc.connect(gain); gain.connect(this.ctx.destination);
                osc.frequency.value = freq; osc.type = type;
                gain.gain.setValueAtTime(vol, this.ctx.currentTime);
                gain.gain.exponentialRampToValueAtTime(0.01, this.ctx.currentTime + dur);
                osc.start(); osc.stop(this.ctx.currentTime + dur);
            },
            shoot() { this.play(400, 0.05, "square", 0.1); },
            hit() { this.play(150, 0.1, "sawtooth", 0.15); },
            kill() { this.play(200, 0.1); setTimeout(() => this.play(300, 0.1), 50); },
            collect() { this.play(600, 0.1, "sine"); setTimeout(() => this.play(800, 0.1, "sine"), 50); },
            levelUp() { [523, 659, 784, 1047].forEach((f,i) => setTimeout(() => this.play(f, 0.2), i*100)); },
            damage() { this.play(100, 0.15, "sawtooth"); }
        };
        let screenShake = { x: 0, y: 0, intensity: 0 };
        function shakeScreen(i) { screenShake.intensity = Math.max(screenShake.intensity, i); }
        function updateShake() { if (screenShake.intensity > 0) { screenShake.x = (Math.random()-0.5)*screenShake.intensity*2; screenShake.y = (Math.random()-0.5)*screenShake.intensity*2; screenShake.intensity *= 0.9; if (screenShake.intensity < 0.5) screenShake.intensity = 0; } else { screenShake.x = 0; screenShake.y = 0; } }

        const canvas = document.getElementById('gameCanvas');
        const ctx = canvas.getContext('2d');

        // Game state
        let gameStarted = false;
        let gameOver = false;
        let gamePaused = false;
        let keys = {};
        let tempStatAllocations = {
            health: 0,
            attack: 0,
            speed: 0,
            firerate: 0
        };

        // Grid system (for building)
        const GRID_SIZE = 40;

        // Camera system
        const camera = {
            x: 0,
            y: 0
        };

        // World bounds (expandable)
        let worldBounds = {
            width: 800,
            height: 600,
            expand: function() {
                this.width += 400;
                this.height += 300;
            }
        };

        // Player
        const player = {
            x: 400,
            y: 300,
            size: 30,
            speed: 3,
            baseSpeed: 3,
            health: 100,
            maxHealth: 100,
            baseMaxHealth: 100,
            attack: 25,
            baseAttack: 25,
            fireRate: 500,
            lastShot: 0,
            level: 1,
            exp: 0,
            expToLevel: 100,
            statPoints: 0,
            class: null, // 'warrior', 'bowman', 'magician', 'assassin'
            projectileStyle: 'normal'
        };

        // Resources - Soul Currency
        const resources = {
            souls: 50  // Single currency - Souls
        };

        // Game stats
        let score = 0;
        let wave = 1;
        let enemiesInWave = 0;
        let enemiesKilled = 0;
        let waveTimer = 30; // seconds between waves
        let timeSinceWave = 0;

        // Arrays
        let projectiles = [];
        let enemies = [];
        let resourceNodes = [];
        let buildings = [];

        // Soul types with colors and values
        const soulTypes = {
            red: { color: '#ff3333', value: 5, unlockWave: 1 },
            orange: { color: '#ff9933', value: 10, unlockWave: 3 },
            yellow: { color: '#ffff33', value: 15, unlockWave: 5 },
            green: { color: '#33ff33', value: 25, unlockWave: 7 },
            blue: { color: '#3366ff', value: 40, unlockWave: 10 },
            purple: { color: '#9933ff', value: 60, unlockWave: 13 }
        };

        // Get available soul types based on current wave
        function getAvailableSoulTypes() {
            return Object.keys(soulTypes).filter(type => soulTypes[type].unlockWave <= wave);
        }

        // Resource node class (Souls)
        class ResourceNode {
            constructor(x, y, type = null) {
                this.x = x;
                this.y = y;
                
                // If no type specified, pick random from available types
                if (!type) {
                    const availableTypes = getAvailableSoulTypes();
                    type = availableTypes[Math.floor(Math.random() * availableTypes.length)];
                }
                
                this.type = type; // 'red', 'orange', 'yellow', 'green', 'blue', 'purple'
                this.soulData = soulTypes[type];
                this.size = 20;
                this.glowPhase = Math.random() * Math.PI * 2;
                this.floatOffset = Math.random() * Math.PI * 2;
                this.collected = false;
            }

            draw(timestamp) {
                // Floating animation
                const floatY = Math.sin(this.floatOffset + timestamp * 0.002) * 5;
                const currentY = this.y + floatY;
                
                // Pulsing glow effect
                const pulse = Math.sin(this.glowPhase + timestamp * 0.004) * 0.3 + 0.7;
                
                // Outer glow
                const gradient = ctx.createRadialGradient(
                    this.x, currentY, 0,
                    this.x, currentY, this.size * pulse * 1.5
                );
                gradient.addColorStop(0, this.soulData.color);
                gradient.addColorStop(0.5, this.soulData.color + '88'); // Semi-transparent
                gradient.addColorStop(1, this.soulData.color + '00'); // Fully transparent
                
                ctx.fillStyle = gradient;
                ctx.beginPath();
                ctx.arc(this.x, currentY, this.size * pulse * 1.5, 0, Math.PI * 2);
                ctx.fill();
                
                // Soul orb body
                ctx.fillStyle = this.soulData.color;
                ctx.beginPath();
                ctx.arc(this.x, currentY, this.size * 0.6, 0, Math.PI * 2);
                ctx.fill();
                
                // Inner core (lighter)
                const coreColor = this.getLighterColor(this.soulData.color);
                ctx.fillStyle = coreColor;
                ctx.beginPath();
                ctx.arc(this.x - 3, currentY - 3, this.size * 0.25, 0, Math.PI * 2);
                ctx.fill();
                
                // Wispy soul trails
                ctx.strokeStyle = this.soulData.color + '66';
                ctx.lineWidth = 2;
                const wispTime = timestamp * 0.003;
                for (let i = 0; i < 3; i++) {
                    ctx.beginPath();
                    const angle = (wispTime + i * Math.PI * 0.66) % (Math.PI * 2);
                    const wispX = this.x + Math.cos(angle) * this.size * 0.8;
                    const wispY = currentY + Math.sin(angle) * this.size * 0.8;
                    ctx.moveTo(this.x, currentY);
                    ctx.lineTo(wispX, wispY);
                    ctx.stroke();
                }
            }

            getLighterColor(hexColor) {
                // Convert hex to lighter version
                const r = parseInt(hexColor.substr(1, 2), 16);
                const g = parseInt(hexColor.substr(3, 2), 16);
                const b = parseInt(hexColor.substr(5, 2), 16);
                return `rgb(${Math.min(255, r + 80)}, ${Math.min(255, g + 80)}, ${Math.min(255, b + 80)})`;
            }

            collect() {
                resources.souls += this.soulData.value; AudioSystem.collect();
                this.collected = true;
            }
        }

        // Building class
        class Building {
            constructor(x, y, type) {
                this.x = x;
                this.y = y;
                this.type = type;
                this.size = GRID_SIZE - 5;
                this.health = type === 'wall' ? 100 : type === 'turret' ? 80 : 50;
                this.maxHealth = this.health;
                this.lastShot = 0;
                this.fireRate = 1000; // for turrets
            }

            draw() {
                // Draw based on type with energy theme
                if (this.type === 'wall') {
                    // Energy barrier - glowing blue
                    ctx.fillStyle = '#1a4d7a';
                    ctx.fillRect(this.x, this.y, this.size, this.size);
                    
                    // Energy grid pattern
                    ctx.strokeStyle = '#00ddff';
                    ctx.lineWidth = 2;
                    for (let i = 0; i < this.size; i += 10) {
                        ctx.beginPath();
                        ctx.moveTo(this.x + i, this.y);
                        ctx.lineTo(this.x + i, this.y + this.size);
                        ctx.stroke();
                        ctx.beginPath();
                        ctx.moveTo(this.x, this.y + i);
                        ctx.lineTo(this.x + this.size, this.y + i);
                        ctx.stroke();
                    }
                    
                    // Glow effect
                    ctx.shadowColor = '#00ddff';
                    ctx.shadowBlur = 10;
                    ctx.strokeRect(this.x, this.y, this.size, this.size);
                    ctx.shadowBlur = 0;
                    
                } else if (this.type === 'turret') {
                    // Laser turret - purple/pink energy
                    ctx.fillStyle = '#2a1a4a';
                    ctx.fillRect(this.x, this.y, this.size, this.size);
                    
                    // Energy core
                    const gradient = ctx.createRadialGradient(
                        this.x + this.size/2, this.y + this.size/2, 5,
                        this.x + this.size/2, this.y + this.size/2, 15
                    );
                    gradient.addColorStop(0, '#ff66ff');
                    gradient.addColorStop(1, '#aa44ff');
                    ctx.fillStyle = gradient;
                    ctx.beginPath();
                    ctx.arc(this.x + this.size/2, this.y + this.size/2, 12, 0, Math.PI * 2);
                    ctx.fill();
                    
                    // Barrel indicators
                    ctx.fillStyle = '#ff44ff';
                    ctx.fillRect(this.x + this.size/2 - 3, this.y, 6, 8);
                    ctx.fillRect(this.x + this.size/2 - 3, this.y + this.size - 8, 6, 8);
                    ctx.fillRect(this.x, this.y + this.size/2 - 3, 8, 6);
                    ctx.fillRect(this.x + this.size - 8, this.y + this.size/2 - 3, 8, 6);
                    
                } else if (this.type === 'trap') {
                    // Shock trap - yellow electric
                    ctx.fillStyle = '#3a3a1a';
                    ctx.fillRect(this.x, this.y, this.size, this.size);
                    
                    // Electric arcs
                    ctx.strokeStyle = '#ffff00';
                    ctx.lineWidth = 2;
                    for (let i = 0; i < 4; i++) {
                        ctx.beginPath();
                        ctx.moveTo(this.x + 10 + i * 7, this.y + 5);
                        ctx.lineTo(this.x + 7 + i * 7, this.y + 15);
                        ctx.lineTo(this.x + 13 + i * 7, this.y + 15);
                        ctx.lineTo(this.x + 10 + i * 7, this.y + 25);
                        ctx.stroke();
                    }
                }

                // Health bar for damaged buildings
                if (this.health < this.maxHealth) {
                    ctx.fillStyle = '#333';
                    ctx.fillRect(this.x, this.y - 8, this.size, 4);
                    ctx.fillStyle = '#00ff00';
                    ctx.fillRect(this.x, this.y - 8, this.size * (this.health / this.maxHealth), 4);
                }
            }

            update(timestamp) {
                // Turrets shoot at nearest enemy
                if (this.type === 'turret' && timestamp - this.lastShot > this.fireRate) {
                    const nearestEnemy = findNearestEnemy(this.x + this.size/2, this.y + this.size/2, 250);
                    if (nearestEnemy) {
                        shootProjectile(
                            this.x + this.size/2, 
                            this.y + this.size/2, 
                            nearestEnemy.x, 
                            nearestEnemy.y,
                            'turret'
                        );
                        this.lastShot = timestamp;
                    }
                }
            }
        }

        // Projectile class
        class Projectile {
            constructor(x, y, targetX, targetY, owner = 'player', style = 'normal') {
                this.x = x;
                this.y = y;
                this.size = 5;
                this.speed = 8;
                this.owner = owner;
                this.style = style;
                
                // Adjust properties based on style
                if (style === 'slash') {
                    this.size = 15;
                    this.speed = 6;
                } else if (style === 'arrow') {
                    this.size = 8;
                    this.speed = 12;
                    this.piercing = true;
                } else if (style === 'orb') {
                    this.size = 10;
                    this.speed = 7;
                } else if (style === 'shuriken') {
                    this.size = 6;
                    this.speed = 10;
                }
                
                // Calculate direction
                const dx = targetX - x;
                const dy = targetY - y;
                const dist = Math.sqrt(dx * dx + dy * dy);
                this.vx = (dx / dist) * this.speed;
                this.vy = (dy / dist) * this.speed;
                this.angle = Math.atan2(dy, dx);
                this.damage = owner === 'player' ? player.attack : 25;
                this.rotation = 0;
            }

            update() {
                this.x += this.vx;
                this.y += this.vy;
                this.rotation += 0.2;
            }

            draw() {
                ctx.save();
                ctx.translate(this.x, this.y);
                ctx.rotate(this.angle);
                
                switch(this.style) {
                    case 'slash': // Warrior slash
                        ctx.fillStyle = '#ffaa00';
                        ctx.beginPath();
                        ctx.ellipse(0, 0, 15, 5, 0, 0, Math.PI * 2);
                        ctx.fill();
                        break;
                    case 'arrow': // Bowman arrow
                        ctx.fillStyle = '#00ffff';
                        ctx.beginPath();
                        ctx.moveTo(8, 0);
                        ctx.lineTo(-8, -3);
                        ctx.lineTo(-8, 3);
                        ctx.closePath();
                        ctx.fill();
                        break;
                    case 'orb': // Magician orb
                        const gradient = ctx.createRadialGradient(0, 0, 0, 0, 0, this.size);
                        gradient.addColorStop(0, '#ff00ff');
                        gradient.addColorStop(1, '#aa00ff');
                        ctx.fillStyle = gradient;
                        ctx.beginPath();
                        ctx.arc(0, 0, this.size, 0, Math.PI * 2);
                        ctx.fill();
                        break;
                    case 'shuriken': // Assassin shuriken
                        ctx.fillStyle = '#888';
                        ctx.rotate(this.rotation);
                        for (let i = 0; i < 4; i++) {
                            ctx.beginPath();
                            ctx.moveTo(0, 0);
                            ctx.lineTo(8, 0);
                            ctx.lineTo(6, 2);
                            ctx.closePath();
                            ctx.fill();
                            ctx.rotate(Math.PI / 2);
                        }
                        break;
                    default: // Default/turret
                        ctx.fillStyle = this.owner === 'player' || this.owner === 'turret' ? '#ffff00' : '#ff0000';
                        ctx.beginPath();
                        ctx.arc(0, 0, this.size, 0, Math.PI * 2);
                        ctx.fill();
                }
                
                ctx.restore();
            }

            isOffScreen() {
                return this.x < -50 || this.x > worldBounds.width + 50 || 
                       this.y < -50 || this.y > worldBounds.height + 50;
            }
        }

        // Enemy class
        class Enemy {
            constructor(wave) {
                // Spawn at random edge of world bounds
                const edge = Math.floor(Math.random() * 4);
                if (edge === 0) { // Top
                    this.x = Math.random() * worldBounds.width;
                    this.y = -20;
                } else if (edge === 1) { // Right
                    this.x = worldBounds.width + 20;
                    this.y = Math.random() * worldBounds.height;
                } else if (edge === 2) { // Bottom
                    this.x = Math.random() * worldBounds.width;
                    this.y = worldBounds.height + 20;
                } else { // Left
                    this.x = -20;
                    this.y = Math.random() * worldBounds.height;
                }

                this.size = 15;
                this.speed = 1 + (wave * 0.1);
                this.health = 50 + (wave * 10);
                this.maxHealth = this.health;
                this.damage = 5 + wave;
                this.attackCooldown = 0;
            }

            update() {
                // Move toward player
                const dx = player.x - this.x;
                const dy = player.y - this.y;
                const dist = Math.sqrt(dx * dx + dy * dy);
                
                if (dist > 25) {
                    this.x += (dx / dist) * this.speed;
                    this.y += (dy / dist) * this.speed;
                } else {
                    // Attack player
                    if (this.attackCooldown <= 0) {
                        player.health -= this.damage; AudioSystem.damage(); shakeScreen(5);
                        this.attackCooldown = 60; // frames
                    }
                }

                if (this.attackCooldown > 0) this.attackCooldown--;
            }

            draw() {
                // Enemy body
                ctx.fillStyle = '#ff3333';
                ctx.fillRect(this.x - this.size/2, this.y - this.size/2, this.size, this.size);
                
                // Eyes
                ctx.fillStyle = '#000';
                ctx.fillRect(this.x - 5, this.y - 5, 3, 3);
                ctx.fillRect(this.x + 2, this.y - 5, 3, 3);

                // Health bar
                ctx.fillStyle = '#333';
                ctx.fillRect(this.x - this.size/2, this.y - this.size/2 - 8, this.size, 4);
                ctx.fillStyle = '#00ff00';
                ctx.fillRect(this.x - this.size/2, this.y - this.size/2 - 8, this.size * (this.health / this.maxHealth), 4);
            }
        }

        // Initialize resource nodes (Souls)
        function initResourceNodes() {
            resourceNodes = [];
            // Spawn souls based on available types for current wave
            const availableTypes = getAvailableSoulTypes();
            
            for (let i = 0; i < 20; i++) {
                resourceNodes.push(new ResourceNode(
                    50 + Math.random() * (worldBounds.width - 100),
                    50 + Math.random() * (worldBounds.height - 100)
                    // Type will be auto-selected based on wave
                ));
            }
        }

        // Spawn additional souls in expanded world
        function spawnAdditionalSouls(count) {
            for (let i = 0; i < count; i++) {
                resourceNodes.push(new ResourceNode(
                    50 + Math.random() * (worldBounds.width - 100),
                    50 + Math.random() * (worldBounds.height - 100)
                ));
            }
        }

        // Spawn enemies for wave
        function spawnWave() {
            enemiesInWave = 5 + (wave * 3);
            for (let i = 0; i < enemiesInWave; i++) {
                setTimeout(() => {
                    enemies.push(new Enemy(wave));
                }, i * 500);
            }
        }

        // Shoot projectile
        function shootProjectile(fromX, fromY, toX, toY, owner = 'player', style = 'normal') {
            AudioSystem.shoot(); projectiles.push(new Projectile(fromX, fromY, toX, toY, owner, style));
        }

        // Find nearest enemy
        function findNearestEnemy(x, y, maxDist = Infinity) {
            let nearest = null;
            let minDist = maxDist;
            
            enemies.forEach(enemy => {
                const dx = enemy.x - x;
                const dy = enemy.y - y;
                const dist = Math.sqrt(dx * dx + dy * dy);
                if (dist < minDist) {
                    minDist = dist;
                    nearest = enemy;
                }
            });
            
            return nearest;
        }

        // Update UI
        function updateUI() {
            // Health
            const healthPercent = Math.max(0, (player.health / player.maxHealth) * 100);
            document.getElementById('healthBar').style.width = `${healthPercent}%`;
            document.getElementById('healthText').textContent = `${Math.max(0, Math.floor(player.health))}/${player.maxHealth}`;
            
            // EXP
            const expPercent = (player.exp / player.expToLevel) * 100;
            document.getElementById('expBar').style.width = `${expPercent}%`;
            document.getElementById('expText').textContent = `${player.exp}/${player.expToLevel}`;
            
            // Level
            document.getElementById('playerLevel').textContent = player.level;
            
            // Currency
            document.getElementById('soulsCount').textContent = resources.souls;
            document.getElementById('score').textContent = score;
            
            // Wave info
            document.getElementById('waveNumber').textContent = wave;
            document.getElementById('enemyCount').textContent = `Enemies: ${enemies.length}`;
            document.getElementById('worldSize').textContent = `World: ${worldBounds.width} x ${worldBounds.height}`;
            
            if (enemies.length === 0 && gameStarted) {
                document.getElementById('waveTimer').textContent = `Next wave in: ${Math.max(0, waveTimer - Math.floor(timeSinceWave/60))}s`;
            } else {
                document.getElementById('waveTimer').textContent = 'Wave in progress';
            }
        }

        // Show stat allocation panel
        function showStatAllocationPanel() {
            // Don't pause game anymore - just open the tab
            tempStatAllocations = { health: 0, attack: 0, speed: 0, firerate: 0 };
            
            document.getElementById('levelUpNumber').textContent = player.level;
            document.getElementById('availablePoints').textContent = player.statPoints;
            updateStatDisplay();
            
            // Auto-open and pulse the tab
            document.getElementById('statAllocationPanel').classList.add('open');
            document.getElementById('statMenuTab').classList.add('has-points');
        }

        // Toggle stat menu
        function toggleStatMenu() {
            const menu = document.getElementById('statAllocationPanel');
            menu.classList.toggle('open');
        }

        // Allocate stat point
        function allocateStat(stat) {
            if (player.statPoints <= 0) return;
            
            tempStatAllocations[stat]++;
            player.statPoints--;
            
            updateStatDisplay();
            
            // Enable confirm button when all points are spent
            document.getElementById('confirmBtn').disabled = player.statPoints > 0;
        }

        // Update stat display in panel
        function updateStatDisplay() {
            document.getElementById('availablePoints').textContent = player.statPoints;
            
            // Update current stat displays with preview
            document.getElementById('currentMaxHP').textContent = 
                player.baseMaxHealth + (tempStatAllocations.health * 20);
            
            document.getElementById('currentAttack').textContent = 
                player.baseAttack + (tempStatAllocations.attack * 5);
            
            document.getElementById('currentSpeed').textContent = 
                (player.baseSpeed + (tempStatAllocations.speed * 0.3)).toFixed(1);
            
            document.getElementById('currentFireRate').textContent = 
                Math.max(100, player.fireRate - (tempStatAllocations.firerate * 50)) + 'ms';
            
            // Enable/disable plus buttons based on available points
            const canAllocate = player.statPoints > 0;
            document.querySelectorAll('.stat-plus-btn').forEach(btn => {
                btn.disabled = !canAllocate;
            });
        }

        // Confirm stat allocation
        function confirmStats() {
            if (tempStatAllocations.health === 0 && tempStatAllocations.attack === 0 && 
                tempStatAllocations.speed === 0 && tempStatAllocations.firerate === 0) {
                return; // Nothing to apply
            }
            
            // Apply stat increases
            player.baseMaxHealth += tempStatAllocations.health * 20;
            player.maxHealth = player.baseMaxHealth;
            const healthRestored = tempStatAllocations.health * 20;
            player.health = Math.min(player.maxHealth, player.health + healthRestored);
            
            player.baseAttack += tempStatAllocations.attack * 5;
            player.attack = player.baseAttack;
            
            player.baseSpeed += tempStatAllocations.speed * 0.3;
            player.speed = player.baseSpeed;
            
            player.fireRate = Math.max(100, player.fireRate - (tempStatAllocations.firerate * 50));
            
            // Remove pulse animation
            document.getElementById('statMenuTab').classList.remove('has-points');
            
            // Reset temp allocations
            tempStatAllocations = { health: 0, attack: 0, speed: 0, firerate: 0 };
            
            updateUI();
            updateStatDisplay();
        }

        // Game loop
        let lastTimestamp = 0;
        function gameLoop(timestamp) {
            if (!gameStarted || gameOver) {
                if (!gameOver) {
                    requestAnimationFrame(gameLoop);
                }
                return;
            }

            const deltaTime = timestamp - lastTimestamp;
            lastTimestamp = timestamp;

            // Clear canvas
            ctx.fillStyle = '#2d5016';
            ctx.fillRect(0, 0, canvas.width, canvas.height);

            // Draw world boundary
            ctx.strokeStyle = '#ffaa00';
            ctx.lineWidth = 4;
            ctx.strokeRect(0, 0, worldBounds.width, worldBounds.height);

            // Draw boundary fill (darker area outside)
            ctx.fillStyle = 'rgba(0, 0, 0, 0.5)';
            // Top
            ctx.fillRect(-1000, -1000, worldBounds.width + 2000, 1000);
            // Bottom
            ctx.fillRect(-1000, worldBounds.height, worldBounds.width + 2000, 1000);
            // Left
            ctx.fillRect(-1000, 0, 1000, worldBounds.height);
            // Right
            ctx.fillRect(worldBounds.width, 0, 1000, worldBounds.height);

            // Update player movement
            if (keys['w'] || keys['W']) player.y -= player.speed;
            if (keys['s'] || keys['S']) player.y += player.speed;
            if (keys['a'] || keys['A']) player.x -= player.speed;
            if (keys['d'] || keys['D']) player.x += player.speed;

            // Keep player within world bounds
            player.x = Math.max(player.size, Math.min(worldBounds.width - player.size, player.x));
            player.y = Math.max(player.size, Math.min(worldBounds.height - player.size, player.y));

            // Update camera to follow player (keep player centered)
            camera.x = player.x - canvas.width / 2;
            camera.y = player.y - canvas.height / 2;

            // Keep camera within world bounds
            camera.x = Math.max(0, Math.min(worldBounds.width - canvas.width, camera.x));
            camera.y = Math.max(0, Math.min(worldBounds.height - canvas.height, camera.y));

            // Apply camera transform
            ctx.save();
            updateShake(); ctx.translate(-camera.x + screenShake.x, -camera.y + screenShake.y);

            // Auto-collect resources on contact
            resourceNodes.forEach((node, i) => {
                const dx = player.x - node.x;
                const dy = player.y - node.y;
                const dist = Math.sqrt(dx * dx + dy * dy);
                
                if (dist < player.size + node.size && !node.collected) {
                    node.collect();
                    resourceNodes.splice(i, 1);
                    
                    // Respawn soul after delay (random type based on current wave)
                    setTimeout(() => {
                        resourceNodes.push(new ResourceNode(
                            50 + Math.random() * (worldBounds.width - 100),
                            50 + Math.random() * (worldBounds.height - 100)
                        ));
                    }, 10000); // 10 seconds
                }
            });

            // Auto-shoot at nearest enemy
            if (enemies.length > 0 && timestamp - player.lastShot > player.fireRate) {
                const target = findNearestEnemy(player.x, player.y);
                if (target) {
                    // Different attack patterns based on class
                    switch(player.projectileStyle) {
                        case 'slash': // Warrior - single powerful slash
                            shootProjectile(player.x, player.y, target.x, target.y, 'player', 'slash');
                            break;
                        case 'arrow': // Bowman - single piercing arrow
                            shootProjectile(player.x, player.y, target.x, target.y, 'player', 'arrow');
                            break;
                        case 'orb': // Magician - 3 orbiting orbs
                            for (let i = 0; i < 3; i++) {
                                const angle = (i / 3) * Math.PI * 2;
                                const offsetX = Math.cos(angle) * 30;
                                const offsetY = Math.sin(angle) * 30;
                                shootProjectile(player.x + offsetX, player.y + offsetY, target.x, target.y, 'player', 'orb');
                            }
                            break;
                        case 'shuriken': // Assassin - triple burst
                            for (let i = 0; i < 3; i++) {
                                setTimeout(() => {
                                    if (enemies.length > 0) {
                                        const newTarget = findNearestEnemy(player.x, player.y);
                                        if (newTarget) {
                                            shootProjectile(player.x, player.y, newTarget.x, newTarget.y, 'player', 'shuriken');
                                        }
                                    }
                                }, i * 50);
                            }
                            break;
                        default:
                            shootProjectile(player.x, player.y, target.x, target.y);
                    }
                    player.lastShot = timestamp;
                }
            }

            // Update projectiles
            projectiles.forEach((proj, i) => {
                proj.update();
                
                // Check collision with enemies
                if (proj.owner === 'player' || proj.owner === 'turret') {
                    let hitEnemy = false;
                    enemies.forEach((enemy, j) => {
                        const dx = proj.x - enemy.x;
                        const dy = proj.y - enemy.y;
                        const dist = Math.sqrt(dx * dx + dy * dy);
                        
                        if (dist < enemy.size + proj.size) {
                            enemy.health -= proj.damage;
                            
                            // Only remove projectile if not piercing
                            if (!proj.piercing && !hitEnemy) {
                                projectiles.splice(i, 1);
                                hitEnemy = true;
                            }
                            
                            if (enemy.health <= 0) {
                                enemies.splice(j, 1);
                                score += 10 + (wave * 5);
                                
                                // Gain EXP
                                const expGain = 10 + (wave * 2);
                                player.exp += expGain;
                                
                                // Check for level up
                                if (player.exp >= player.expToLevel) {
                                    player.exp -= player.expToLevel;
                                    player.level++; AudioSystem.levelUp();
                                    player.expToLevel = Math.floor(player.expToLevel * 1.2);
                                    
                                    // Give stat points (5 points per level)
                                    player.statPoints += 5;
                                    
                                    // Show stat allocation panel
                                    showStatAllocationPanel();
                                }
                                
                                enemiesKilled++;
                            }
                        }
                    });
                }

                // Remove off-screen projectiles
                if (proj.isOffScreen()) {
                    projectiles.splice(i, 1);
                }
            });

            // Update enemies
            enemies.forEach((enemy, i) => {
                enemy.update();
                
                // Check collision with buildings
                buildings.forEach((building, j) => {
                    const dx = enemy.x - (building.x + building.size/2);
                    const dy = enemy.y - (building.y + building.size/2);
                    const dist = Math.sqrt(dx * dx + dy * dy);
                    
                    if (dist < enemy.size + building.size/2) {
                        building.health -= 0.5;
                        
                        // Trap damage
                        if (building.type === 'trap') {
                            enemy.health -= 2;
                            if (enemy.health <= 0) {
                                enemies.splice(i, 1); AudioSystem.kill();
                                score += 10 + (wave * 5);
                            }
                        }
                        
                        if (building.health <= 0) {
                            buildings.splice(j, 1);
                        }
                    }
                });
            });

            // Update buildings
            buildings.forEach(building => {
                building.update(timestamp);
            });

            // Wave management
            if (enemies.length === 0 && gameStarted) {
                timeSinceWave++;
                if (timeSinceWave >= waveTimer * 60) { // 60 fps
                    const previousWave = wave;
                    wave++;
                    
                    // Check for new soul unlocks
                    const previousTypes = Object.keys(soulTypes).filter(type => soulTypes[type].unlockWave <= previousWave);
                    const currentTypes = Object.keys(soulTypes).filter(type => soulTypes[type].unlockWave <= wave);
                    
                    if (currentTypes.length > previousTypes.length) {
                        // New soul type unlocked!
                        const newType = currentTypes[currentTypes.length - 1];
                        const soulData = soulTypes[newType];
                        
                        const unlockNotif = document.getElementById('soulUnlocked');
                        unlockNotif.innerHTML = `üëª NEW SOUL UNLOCKED! üëª<br><br><span style="color: ${soulData.color}; font-size: 36px;">‚¨§</span><br>${newType.toUpperCase()}<br>Value: ${soulData.value} Souls`;
                        unlockNotif.style.borderColor = soulData.color;
                        unlockNotif.style.display = 'block';
                        
                        // Spawn some of the new soul type immediately
                        for (let i = 0; i < 3; i++) {
                            resourceNodes.push(new ResourceNode(
                                50 + Math.random() * (worldBounds.width - 100),
                                50 + Math.random() * (worldBounds.height - 100),
                                newType
                            ));
                        }
                        
                        setTimeout(() => {
                            unlockNotif.style.display = 'none';
                        }, 4000);
                    }
                    
                    // Expand world every 3 waves
                    if (wave % 3 === 0) {
                        worldBounds.expand();
                        
                        // Show expansion notification
                        const expandNotif = document.getElementById('worldExpanded');
                        expandNotif.style.display = 'block';
                        setTimeout(() => {
                            expandNotif.style.display = 'none';
                        }, 3000);
                        
                        
                        // Add more souls in the expanded area
                        spawnAdditionalSouls(10);
                    }
                    
                    spawnWave();
                    timeSinceWave = 0;
                }
            }

            // Draw resource nodes
            resourceNodes.forEach(node => node.draw(timestamp));

            // Draw buildings
            buildings.forEach(building => building.draw());

            // Draw player
            ctx.fillStyle = '#4169E1';
            ctx.fillRect(player.x - player.size/2, player.y - player.size/2, player.size, player.size);
            ctx.fillStyle = '#fff';
            ctx.fillRect(player.x - 5, player.y - 5, 3, 3);
            ctx.fillRect(player.x + 2, player.y - 5, 3, 3);

            // Draw projectiles
            projectiles.forEach(proj => proj.draw());

            // Draw enemies
            enemies.forEach(enemy => enemy.draw());

            // Restore camera transform
            ctx.restore();

            // Update UI
            updateUI();

            // Check game over
            if (player.health <= 0) {
                gameOver = true;
                document.getElementById('finalWave').textContent = wave;
                document.getElementById('finalScore').textContent = score;
                document.getElementById('gameOver').style.display = 'block';
                return;
            }

            requestAnimationFrame(gameLoop);
        }

        // Start game
        function startGame() {
            document.getElementById('instructions').style.display = 'none';
            document.getElementById('classSelection').style.display = 'block';
        }

        // Select class
        function selectClass(className) {
            player.class = className;
            
            // Apply class bonuses
            switch(className) {
                case 'warrior':
                    player.baseMaxHealth = 150;
                    player.maxHealth = 150;
                    player.health = 150;
                    player.baseAttack = 35;
                    player.attack = 35;
                    player.baseSpeed = 2.5;
                    player.speed = 2.5;
                    player.projectileStyle = 'slash';
                    break;
                case 'bowman':
                    player.baseMaxHealth = 80;
                    player.maxHealth = 80;
                    player.health = 80;
                    player.baseAttack = 20;
                    player.attack = 20;
                    player.baseSpeed = 3.5;
                    player.speed = 3.5;
                    player.fireRate = 400;
                    player.projectileStyle = 'arrow';
                    break;
                case 'magician':
                    player.baseMaxHealth = 90;
                    player.maxHealth = 90;
                    player.health = 90;
                    player.baseAttack = 30;
                    player.attack = 30;
                    player.baseSpeed = 3;
                    player.speed = 3;
                    player.fireRate = 700;
                    player.projectileStyle = 'orb';
                    break;
                case 'assassin':
                    player.baseMaxHealth = 70;
                    player.maxHealth = 70;
                    player.health = 70;
                    player.baseAttack = 15;
                    player.attack = 15;
                    player.baseSpeed = 4;
                    player.speed = 4;
                    player.fireRate = 300;
                    player.projectileStyle = 'shuriken';
                    break;
            }
            
            document.getElementById('classSelection').style.display = 'none';
            gameStarted = true;
            initResourceNodes();
            spawnWave();
            requestAnimationFrame(gameLoop);
        }

        // Event listeners
        window.addEventListener('keydown', (e) => {
            keys[e.key] = true;
        });

        window.addEventListener('keyup', (e) => {
            keys[e.key] = false;
        });

        // Initialize
        updateUI();
    </script>
</body>
</html>
